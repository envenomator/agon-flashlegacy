; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optsize -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\main.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME0",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME1"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME2"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME2",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",51
.DEFINE "clock"
.VALUE 0
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "vpd_protocol_flags"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "keyascii"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "keymods"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "cursorX"
.VALUE 7
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "cursorY"
.VALUE 8
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "scrchar"
.VALUE 9
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "scrpixel"
.VALUE 10
.CLASS 8
.TYPE 14
.ENDEF
.DEFINE "audioChannel"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "audioSuccess"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "scrwidth"
.VALUE 15
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "scrheight"
.VALUE 17
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "scrcols"
.VALUE 19
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "scrrows"
.VALUE 20
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "scrcolours"
.VALUE 21
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "scrpixelIndex"
.VALUE 22
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "keycode"
.VALUE 23
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "keydown"
.VALUE 24
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "keycount"
.VALUE 25
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "rtc"
.VALUE 26
.CLASS 8
.DIM 6
.TYPE 108
.ENDEF
.DEFINE "rtc_spare"
.VALUE 32
.CLASS 8
.DIM 2
.TYPE 108
.ENDEF
.DEFINE "keydelay"
.VALUE 34
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "keyrate"
.VALUE 36
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "keyled"
.VALUE 38
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "scrmode"
.VALUE 39
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "rtc_enable"
.VALUE 40
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "mouseX"
.VALUE 41
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "mouseY"
.VALUE 43
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "mouseButtons"
.VALUE 45
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "mouseWheel"
.VALUE 46
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "mouseXDelta"
.VALUE 47
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "mouseYDelta"
.VALUE 49
.CLASS 8
.TYPE 13
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",8
.DEFINE "baudRate"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "dataBits"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stopBits"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "parity"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flowcontrol"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "eir"
.VALUE 7
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",15
.DEFINE "fs"
.VALUE 0
.CLASS 8
.TYPE 46
.ENDEF
.DEFINE "id"
.VALUE 3
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "attr"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stat"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "sclust"
.VALUE 7
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "objsize"
.VALUE 11
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME5"
.BEGREC "NONAME6",36
.DEFINE "obj"
.VALUE 0
.CLASS 8
.TAG "NONAME5"
.TYPE 8
.ENDEF
.DEFINE "flag"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "err"
.VALUE 16
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "fptr"
.VALUE 17
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "clust"
.VALUE 21
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "sect"
.VALUE 25
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir_sect"
.VALUE 29
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir_ptr"
.VALUE 33
.CLASS 8
.TYPE 46
.ENDEF
.ENDREC "NONAME6"
	SEGMENT BSS
_errno:
	DS	3
.DEFINE "errno"
.ALIAS "_errno"
.CLASS 83
.VALUE _errno
.TYPE 4
.ENDEF
	SEGMENT DATA
_flashmos:
	DB	0
.DEFINE "flashmos"
.ALIAS "_flashmos"
.CLASS 69
.VALUE _flashmos
.TYPE 12
.ENDEF
	SEGMENT BSS
_mosfilename:
	DS	256
.DEFINE "mosfilename"
.ALIAS "_mosfilename"
.CLASS 83
.VALUE _mosfilename
.DIM 256
.TYPE 98
.ENDEF
_moscrc:
	DS	4*1
.DEFINE "moscrc"
.ALIAS "_moscrc"
.CLASS 83
.VALUE _moscrc
.TYPE 15
.ENDEF
	SEGMENT DATA
_flashvdp:
	DB	0
.DEFINE "flashvdp"
.ALIAS "_flashvdp"
.CLASS 69
.VALUE _flashvdp
.TYPE 12
.ENDEF
	SEGMENT BSS
_vdpfilename:
	DS	256
.DEFINE "vdpfilename"
.ALIAS "_vdpfilename"
.CLASS 83
.VALUE _vdpfilename
.DIM 256
.TYPE 98
.ENDEF
_vdpcrc:
	DS	4*1
.DEFINE "vdpcrc"
.ALIAS "_vdpcrc"
.CLASS 83
.VALUE _vdpcrc
.TYPE 15
.ENDEF
	SEGMENT DATA
_optbatch:
	DB	0
.DEFINE "optbatch"
.ALIAS "_optbatch"
.CLASS 69
.VALUE _optbatch
.TYPE 12
.ENDEF
_optforce:
	DB	0
.DEFINE "optforce"
.ALIAS "_optforce"
.CLASS 69
.VALUE _optforce
.TYPE 12
.ENDEF
;    1	/*
;    2	 * Title:			Agon firmware upgrade utility
;    3	 * Author:			Jeroen Venema
;    4	 * Created:			17/12/2022
;    5	 * Last Updated:	02/11/2023
;    6	 * 
;    7	 * Modinfo:
;    8	 * 17/12/2022:		Initial version
;    9	 * 05/04/2022:		Changed timer to 5sec at reset.
;   10	 *                  Sends cls just before reset
;   11	 * 07/06/2023:		Included faster crc32, by Leigh Brown
;   12	 * 14/10/2023:		VDP update code, MOS update rewritten for simplicity
;   13	 * 02/11/2023:		Batched mode, rewrite of UI
;   14	 */
;   15	
;   16	#include <ez80.h>
;   17	#include <stdio.h>
;   18	#include <stdlib.h>
;   19	#include <ERRNO.H>
;   20	#include <ctype.h>
;   21	#include "mos-interface.h"
;   22	#include "flash.h"
;   23	#include "agontimer.h"
;   24	#include "crc32.h"
;   25	#include "filesize.h"
;   26	#include "./stdint.h"
;   27	#include <string.h>
;   28	
;   29	#define UNLOCKMATCHLENGTH 9
;   30	#define EXIT_FILENOTFOUND	4
;   31	#define EXIT_INVALIDPARAMETER	19
;   32	#define DEFAULT_MOSFIRMWARE	"MOS.bin"
;   33	#define DEFAULT_VDPFIRMWARE	"firmware.bin"
;   34	
;   35	#define CMDUNKNOWN	0
;   36	#define CMDALL		1
;   37	#define CMDMOS		2
;   38	#define CMDVDP		3
;   39	#define CMDFORCE	4
;   40	#define CMDBATCH	5
;   41	
;   42	int errno; // needed by standard library
;   43	enum states{firmware,retry,systemreset};
;   44	
;   45	bool		flashmos = false;
;   46	char		mosfilename[256];
;   47	uint32_t	moscrc;
;   48	bool		flashvdp = false;
;   49	char		vdpfilename[256];
;   50	uint32_t	vdpcrc;
;   51	bool		optbatch = false;
;   52	bool		optforce = false;		// No y/n user input required
	SEGMENT CODE
;   53	
;   54	// separate putch function that doesn't rely on a running MOS firmware
;   55	// UART0 initialization done by MOS firmware previously
;   56	// This utility doesn't run without MOS to load it anyway
;   57	int putch(int c)
;   58	{
_putch:
.DEFINE "_putch"

.VALUE _putch

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "putch",58,"_putch"

.LINE 58

.DEFINE "c"

.CLASS 65

.VALUE 6

.TYPE 4

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
.ENDEF

;   59		UINT8 lsr,temt;
;   60		
;   61		while((UART0_LSR & 0x40) == 0);
L_1:
.LINE 61

	IN0	A,(197)
	AND	A,%40
	UEXT	HL
	LD	L,A
	CALL	__icmpzero
	JR	Z,L_1
;   62		UART0_THR = c;
.LINE 62

	LD	A,(IX+%6)
	OUT0	(192),A
;   63		return c;
.LINE 63

	LD	HL,(IX+%6)
;   64	}
.LINE 64

	LD	SP,IX
	POP	IX
	RET	


;**************************** _putch ***************************
;Name                         Addr/Register   Size   Type
;c                                     IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "putch",64,"_putch"
;   65	
;   66	void beep(unsigned int number) {
_beep:
.DEFINE "_beep"

.VALUE _beep

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "beep",66,"_beep"

.LINE 66

.DEFINE "number"

.CLASS 65

.VALUE 6

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   67		while(number--) {
.LINE 67

	JR	L_5
L_6:
;   68			putch(7);
.LINE 68

	LD	BC,7
	PUSH	BC
	CALL	_putch
	POP	BC
;   69			delayms(250);
.LINE 69

	LD	BC,250
	PUSH	BC
	CALL	_delayms
	POP	BC
;   70		}
L_5:
.LINE 70

	LD	HL,(IX+%6)
	LD	IY,(IX+%6)
	LEA	IY,IY+%FFFFFFFF
	LD	(IX+%6),IY
	CALL	__icmpzero
	JR	NZ,L_6
;   71	}
.LINE 71

	LD	SP,IX
	POP	IX
	RET	


;**************************** _beep ***************************
;Name                         Addr/Register   Size   Type
;_delayms                            IMPORT  -----   function
;_putch                              IMPORT  -----   function
;number                                IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "beep",71,"_beep"
;   72	
;   73	uint8_t getCharAt(uint16_t x, uint16_t y) {
_getCharAt:
.DEFINE "_getCharAt"

.VALUE _getCharAt

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "getCharAt",73,"_getCharAt"

.LINE 73

.DEFINE "x"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE 9

.TYPE 13

.ENDEF

.DEFINE "sysvars"

.CLASS 65

.VALUE -3

.TAG "NONAME3"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
;   74		sysvar_t *sysvars = getsysvars();
.LINE 74

	CALL	_getsysvars
	LD	(IX+%FFFFFFFD),HL
;   75		delayms(20);
.LINE 75

	LD	BC,20
	PUSH	BC
	CALL	_delayms
	POP	BC
;   76		putch(23);
.LINE 76

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;   77		putch(0);
.LINE 77

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;   78		putch(131);
.LINE 78

	LD	BC,131
	PUSH	BC
	CALL	_putch
	POP	BC
;   79		putch(x & 0xFF);
.LINE 79

	LD	BC,(IX+%6)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;   80		putch((x >> 8) & 0xFF);
.LINE 80

	LD	BC,(IX+%6)
	CALL	__stoiu
	LD	A,%8
	CALL	__ishrs_b
	LD	A,L
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;   81		putch(y & 0xFF);
.LINE 81

	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	A,L
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;   82		putch((y >> 8) & 0xFF);
.LINE 82

	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	A,%8
	CALL	__ishrs_b
	LD	A,L
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;   83		delayms(100);
.LINE 83

	LD	BC,100
	PUSH	BC
	CALL	_delayms
	POP	BC
;   84		return sysvars->scrchar;
.LINE 84

	LD	IY,(IX+%FFFFFFFD)
	LD	A,(IY+%9)
;   85	}
.LINE 85

	LD	SP,IX
	POP	IX
	RET	


;**************************** _getCharAt ***************************
;Name                         Addr/Register   Size   Type
;_putch                              IMPORT  -----   function
;_delayms                            IMPORT  -----   function
;_getsysvars                         IMPORT  -----   function
;sysvars                               IX-3      3   variable
;y                                     IX+9      2   parameter
;x                                     IX+6      2   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "getCharAt",85,"_getCharAt"
;   86	
;   87	bool vdp_ota_present(void) {
_vdp_ota_present:
.DEFINE "_vdp_ota_present"

.VALUE _vdp_ota_present

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "vdp_ota_present",87,"_vdp_ota_present"

.LINE 87

.DEFINE "n"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "test"

.CLASS 65

.VALUE -11

.DIM 9

.TYPE 98

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF5
	LD	SP,HL
;   88		char test[UNLOCKMATCHLENGTH];
;   89		uint16_t n;
;   90	
;   91		putch(23);
.LINE 91

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;   92		putch(0);
.LINE 92

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;   93		putch(0xA1);
.LINE 93

	LD	BC,161
	PUSH	BC
	CALL	_putch
	POP	BC
;   94		putch(0);
.LINE 94

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;   95		printf("unlock");
.LINE 95

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__5
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   96	
;   97		for(n = 0; n < UNLOCKMATCHLENGTH+1; n++) test[n] = getCharAt(n+8, 3);
.LINE 97

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
	JR	L_12
L_10:
	LD	BC,3
	PUSH	BC
	LD	IY,(IX+%FFFFFFFE)
	LEA	BC,IY+%8
	PUSH	BC
	CALL	_getCharAt
	POP	BC
	POP	BC
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,HL
	LEA	HL,IX+%FFFFFFF5
	ADD	HL,BC
	LD	(HL),A
	LD	HL,(IX+%FFFFFFFE)
	INC	HL
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
L_12:
	LD.LIS	BC,10
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_10
;   98		// 3 - line on-screen
;   99		if(memcmp(test, "unlocked!",UNLOCKMATCHLENGTH) == 0) return true;
.LINE 99

	LD	BC,9
	PUSH	BC
	LD	BC,L__7
	PUSH	BC
	PEA	IX+%FFFFFFF5
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_14
	LD	A,%1
	JR	L_16
;  100		else return false;
L_14:
.LINE 100

	XOR	A,A
;  101	}
L_16:
.LINE 101

	LD	SP,IX
	POP	IX
	RET	


;**************************** _vdp_ota_present ***************************
;Name                         Addr/Register   Size   Type
;_memcmp                             IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_putch                              IMPORT  -----   function
;test                                 IX-11      9   variable
;n                                     IX-2      2   variable


; Stack Frame Size: 17 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "vdp_ota_present",101,"_vdp_ota_present"
	SEGMENT STRSECT
L__5:
	DB	"unlock"
	DB	0
L__7:
	DB	"unlocked!"
	DB	0
	SEGMENT DATA
_mos_magicnumbers:
	DB	243
	DB	237
	DB	125
	DB	91
	DB	195
.DEFINE "mos_magicnumbers"
.ALIAS "_mos_magicnumbers"
.CLASS 69
.VALUE _mos_magicnumbers
.DIM 5
.TYPE 108
.ENDEF
;  102	
;  103	uint8_t mos_magicnumbers[] = {0xF3, 0xED, 0x7D, 0x5B, 0xC3};
	SEGMENT CODE
;  104	#define MOS_MAGICLENGTH 5
;  105	bool containsMosHeader(uint8_t *filestart) {
_containsMosHeader:
.DEFINE "_containsMosHeader"

.VALUE _containsMosHeader

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "containsMosHeader",105,"_containsMosHeader"

.LINE 105

.DEFINE "filestart"

.CLASS 65

.VALUE 6

.TYPE 44

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "match"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;  106		uint8_t n;
;  107		bool match = true;
.LINE 107

	LD	(IX+%FFFFFFFE),%1
;  108	
;  109		for(n = 0; n < MOS_MAGICLENGTH; n++) if(mos_magicnumbers[n] != filestart[n]) match = false;
.LINE 109

	LD	(IX+%FFFFFFFF),%0
	JR	L_21
L_19:
	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,_mos_magicnumbers
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	Z,L_20
	LD	(IX+%FFFFFFFE),%0
L_20:
	INC	(IX+%FFFFFFFF)
L_21:
	LD	A,(IX+%FFFFFFFF)
	CP	A,%5
	JR	C,L_19
;  110		return match;
.LINE 110

	LD	A,(IX+%FFFFFFFE)
;  111	}
.LINE 111

	LD	SP,IX
	POP	IX
	RET	


;**************************** _containsMosHeader ***************************
;Name                         Addr/Register   Size   Type
;_mos_magicnumbers                   STATIC      5   variable
;match                                 IX-2      1   variable
;n                                     IX-1      1   variable
;filestart                             IX+6      3   parameter


; Stack Frame Size: 11 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "containsMosHeader",111,"_containsMosHeader"
	SEGMENT DATA
_esp32_magicnumbers:
	DB	50
	DB	84
	DB	205
	DB	171
.DEFINE "esp32_magicnumbers"
.ALIAS "_esp32_magicnumbers"
.CLASS 69
.VALUE _esp32_magicnumbers
.DIM 4
.TYPE 108
.ENDEF
;  112	
;  113	uint8_t esp32_magicnumbers[] = {0x32, 0x54, 0xCD, 0xAB};
	SEGMENT CODE
;  114	#define ESP32_MAGICLENGTH 4
;  115	#define ESP32_MAGICSTART 0x20
;  116	bool containsESP32Header(uint8_t *filestart) {
_containsESP32Header:
.DEFINE "_containsESP32Header"

.VALUE _containsESP32Header

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "containsESP32Header",116,"_containsESP32Header"

.LINE 116

.DEFINE "filestart"

.CLASS 65

.VALUE 6

.TYPE 44

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "match"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;  117		uint8_t n;
;  118		bool match = true;
.LINE 118

	LD	(IX+%FFFFFFFE),%1
;  119	
;  120		filestart += ESP32_MAGICSTART; // start of ESP32 magic header
.LINE 120

	LD	IY,(IX+%6)
	LEA	IY,IY+%20
	LD	(IX+%6),IY
;  121		for(n = 0; n < ESP32_MAGICLENGTH; n++) {
.LINE 121

	LD	(IX+%FFFFFFFF),%0
	JR	L_28
L_26:
;  122			if(esp32_magicnumbers[n] != filestart[n]) match = false;
.LINE 122

	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,_esp32_magicnumbers
	ADD	HL,BC
	LD	IY,HL
	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	A,(IY)
	CP	A,(HL)
	JR	Z,L_27
	LD	(IX+%FFFFFFFE),%0
;  123		}
L_27:
.LINE 123

	INC	(IX+%FFFFFFFF)
L_28:
	LD	A,(IX+%FFFFFFFF)
	CP	A,%4
	JR	C,L_26
;  124		return match;
.LINE 124

	LD	A,(IX+%FFFFFFFE)
;  125	}
.LINE 125

	LD	SP,IX
	POP	IX
	RET	


;**************************** _containsESP32Header ***************************
;Name                         Addr/Register   Size   Type
;_esp32_magicnumbers                 STATIC      4   variable
;match                                 IX-2      1   variable
;n                                     IX-1      1   variable
;filestart                             IX+6      3   parameter


; Stack Frame Size: 11 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "containsESP32Header",125,"_containsESP32Header"
;  126	
;  127	void print_version(void) {
_print_version:
.DEFINE "_print_version"

.VALUE _print_version

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "print_version",127,"_print_version"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  128		printf("Agon firmware update utility v1.6\n\r\n\r");
.LINE 128

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__16
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  129	}
.LINE 129

	LD	SP,IX
	POP	IX
	RET	


;**************************** _print_version ***************************
;Name                         Addr/Register   Size   Type
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "print_version",129,"_print_version"
	SEGMENT STRSECT
L__16:
	DB	"Agon firmware update utility v1.6"
	DB	10,13,10,13,0
	SEGMENT CODE
;  130	
;  131	void usage(void) {
_usage:
.DEFINE "_usage"

.VALUE _usage

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "usage",131,"_usage"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  132		print_version();
.LINE 132

	CALL	_print_version
;  133		printf("Usage: FLASH [all | [mos <filename>] [vdp <filename>] | batch] <-f>\n\r");
.LINE 133

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__18
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  134	}
.LINE 134

	LD	SP,IX
	POP	IX
	RET	


;**************************** _usage ***************************
;Name                         Addr/Register   Size   Type
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "usage",134,"_usage"
	SEGMENT STRSECT
L__18:
	DB	"Usage: FLASH [all | [mos <filename>] [vdp <filename>] | batch] <-f>"
	DB	10,13,0
	SEGMENT CODE
;  135	
;  136	typedef enum {
;  137		MOS,
;  138		VDP
;  139	} flashtype;
;  140	
;  141	bool getResponse(void) {
_getResponse:
.DEFINE "_getResponse"

.VALUE _getResponse

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "getResponse",141,"_getResponse"

.LINE 141

.DEFINE "response"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
;  142		uint8_t response = 0;
.LINE 142

	LD	(IX+%FFFFFFFF),%0
;  143	
;  144		printf("Flash firmware (y/n)?");
.LINE 144

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__20
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  145		while((response != 'y') && (response != 'n')) response = tolower(getch());
.LINE 145

	JR	L_34
L_35:
	CALL	_getch
	LD	B,A
	LD	A,B
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	LD	(IX+%FFFFFFFF),L
L_34:
	LD	A,(IX+%FFFFFFFF)
	CP	A,%79
	JR	Z,L_38
	LD	A,(IX+%FFFFFFFF)
	CP	A,%6E
	JR	NZ,L_35
L_38:
;  146		if(response == 'n') printf("\r\nUser abort\n\r\n\r");
.LINE 146

	LD	A,(IX+%FFFFFFFF)
	CP	A,%6E
	JR	NZ,L_37
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__24
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  147		else printf("\r\n\r\n");
.LINE 147

	JR	L_39
L_37:
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__25
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
L_39:
;  148		return response == 'y';
.LINE 148

	LD	A,(IX+%FFFFFFFF)
	CP	A,%79
	JR	NZ,L__27
	LD	A,%1
	JR	L__28
L__27:
	XOR	A,A
L__28:
;  149	}
.LINE 149

	LD	SP,IX
	POP	IX
	RET	


;**************************** _getResponse ***************************
;Name                         Addr/Register   Size   Type
;_getch                              IMPORT  -----   function
;_tolower                            IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;response                              IX-1      1   variable


; Stack Frame Size: 7 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "getResponse",149,"_getResponse"
	SEGMENT STRSECT
L__20:
	DB	"Flash firmware (y/n)?"
	DB	0
L__24:
	DB	13,10
	DB	"User abort"
	DB	10,13,10,13,0
L__25:
	DB	13,10,13,10,0
	SEGMENT CODE
;  150	
;  151	void askEscapeToContinue(void) {
_askEscapeToContinue:
.DEFINE "_askEscapeToContinue"

.VALUE _askEscapeToContinue

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "askEscapeToContinue",151,"_askEscapeToContinue"

.LINE 151

.DEFINE "response"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
;  152		uint8_t response = 0;
.LINE 152

	LD	(IX+%FFFFFFFF),%0
;  153	
;  154		printf("Press ESC to continue");
.LINE 154

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__30
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  155		while(response != 0x1B) response = tolower(getch());
.LINE 155

	JR	L_41
L_42:
	CALL	_getch
	LD	B,A
	LD	A,B
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	LD	(IX+%FFFFFFFF),L
L_41:
	LD	A,(IX+%FFFFFFFF)
	CP	A,%1B
	JR	NZ,L_42
;  156		printf("\r\n");
.LINE 156

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__32
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  157	}
.LINE 157

	LD	SP,IX
	POP	IX
	RET	


;**************************** _askEscapeToContinue ***************************
;Name                         Addr/Register   Size   Type
;_getch                              IMPORT  -----   function
;_tolower                            IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;response                              IX-1      1   variable


; Stack Frame Size: 7 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "askEscapeToContinue",157,"_askEscapeToContinue"
	SEGMENT STRSECT
L__30:
	DB	"Press ESC to continue"
	DB	0
L__32:
	DB	13,10,0
	SEGMENT CODE
;  158	
;  159	bool update_vdp(char *filename) {
_update_vdp:
.DEFINE "_update_vdp"

.VALUE _update_vdp

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "update_vdp",159,"_update_vdp"

.LINE 159

.DEFINE "filename"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "file"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "filesize"

.CLASS 65

.VALUE -4

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;  160		uint8_t file;
;  161		uint24_t filesize;
;  162		uint24_t size, n;
;  163	
;  164		putch(12); // cls
.LINE 164

	LD	BC,12
	PUSH	BC
	CALL	_putch
	POP	BC
;  165		print_version();	
.LINE 165

	CALL	_print_version
;  166		printf("Unlocking VDP updater...\r\n");
.LINE 166

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__34
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  167		
;  168		if(!vdp_ota_present()) {
.LINE 168

	CALL	_vdp_ota_present
	OR	A,A
	JR	NZ,L_46
;  169			printf(" failed - OTA not present in current VDP\r\n\r\n");
.LINE 169

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__36
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  170			printf("Program the VDP using Arduino / PlatformIO / esptool\r\n\r\n");
.LINE 170

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__37
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  171			return false;
.LINE 171

	XOR	A,A
	JR	L_47
;  172		}
L_46:
.LINE 172

;  173	
;  174		file = mos_fopen(filename, fa_read);
.LINE 174

	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFF),A
;  175		// Do actual work here
;  176		printf("Updating VDP firmware\r\n");
.LINE 176

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__38
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  177		filesize = getFileSize(file);	
.LINE 177

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_getFileSize
	POP	BC
	LD	(IX+%FFFFFFFC),HL
;  178		startVDPupdate(file, filesize);
.LINE 178

	LD	BC,HL
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_startVDPupdate
	POP	BC
	POP	BC
;  179		mos_fclose(file);
.LINE 179

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  180		return true;
.LINE 180

	LD	A,%1
;  181	}
L_47:
.LINE 181

	LD	SP,IX
	POP	IX
	RET	


;**************************** _update_vdp ***************************
;Name                         Addr/Register   Size   Type
;_mos_fclose                         IMPORT  -----   function
;_startVDPupdate                     IMPORT  -----   function
;_getFileSize                        IMPORT  -----   function
;_mos_fopen                          IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_putch                              IMPORT  -----   function
;filesize                              IX-4      3   variable
;file                                  IX-1      1   variable
;filename                              IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "update_vdp",181,"_update_vdp"
	SEGMENT STRSECT
L__34:
	DB	"Unlocking VDP updater..."
	DB	13,10,0
L__36:
	DB	" failed - OTA not present in current VDP"
	DB	13,10,13,10,0
L__37:
	DB	"Program the VDP using Arduino / PlatformIO / esptool"
	DB	13,10,13,10,0
L__38:
	DB	"Updating VDP firmware"
	DB	13,10,0
	SEGMENT CODE
;  182	
;  183	bool update_mos(char *filename) {
_update_mos:
.DEFINE "_update_mos"

.VALUE _update_mos

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "update_mos",183,"_update_mos"

.LINE 183

.DEFINE "filename"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "counter"

.CLASS 65

.VALUE -3

.TYPE 14

.ENDEF

.DEFINE "attempt"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

.DEFINE "pagemax"

.CLASS 65

.VALUE -9

.TYPE 14

.ENDEF

.DEFINE "success"

.CLASS 65

.VALUE -10

.TYPE 12

.ENDEF

.DEFINE "addressto"

.CLASS 65

.VALUE -13

.TYPE 14

.ENDEF

.DEFINE "addressfrom"

.CLASS 65

.VALUE -16

.TYPE 14

.ENDEF

.DEFINE "file"

.CLASS 65

.VALUE -17

.TYPE 12

.ENDEF

.DEFINE "ptr"

.CLASS 65

.VALUE -20

.TYPE 34

.ENDEF

.DEFINE "filesize"

.CLASS 65

.VALUE -23

.TYPE 14

.ENDEF

.DEFINE "got"

.CLASS 65

.VALUE -26

.TYPE 14

.ENDEF

.DEFINE "value"

.CLASS 65

.VALUE -27

.TYPE 12

.ENDEF

.DEFINE "lastpagebytes"

.CLASS 65

.VALUE -30

.TYPE 14

.ENDEF

.DEFINE "crcresult"

.CLASS 65

.VALUE -34

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFDB
	LD	SP,HL
;  184		uint32_t crcresult;
;  185		uint24_t got;
;  186		uint8_t file;
;  187		char* ptr = (char*)BUFFER1;
.LINE 187

	LD	BC,327680
	LD	(IX+%FFFFFFEC),BC
;  188		uint8_t value;
;  189		uint24_t counter,pagemax, lastpagebytes;
;  190		uint24_t addressto,addressfrom;
;  191		uint24_t filesize;
;  192		int attempt;
;  193		bool success = false;
.LINE 193

	LD	(IX+%FFFFFFF6),%0
;  194	
;  195		putch(12); // cls
.LINE 195

	LD	BC,12
	PUSH	BC
	CALL	_putch
	POP	BC
;  196		print_version();	
.LINE 196

	CALL	_print_version
;  197		
;  198		printf("Programming MOS firmware to ez80 flash...\r\n\r\n");
.LINE 198

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__40
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  199		printf("Reading MOS firmware");
.LINE 199

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__41
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  200		file = mos_fopen(filename, fa_read);
.LINE 200

	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFEF),A
;  201		filesize = getFileSize(file);
.LINE 201

	LD	C,(IX+%FFFFFFEF)
	LD	B,%0
	PUSH	BC
	CALL	_getFileSize
	POP	BC
	LD	(IX+%FFFFFFE9),HL
;  202		// Read file to memory
;  203		crc32_initialize();
.LINE 203

	CALL	_crc32_initialize
;  204		while((got = mos_fread(file, ptr, BLOCKSIZE)) > 0) {
.LINE 204

	JR	L_48
L_49:
;  205			crc32(ptr, got);
.LINE 205

	LD	BC,(IX+%FFFFFFE6)
	PUSH	BC
	LD	BC,(IX+%FFFFFFEC)
	PUSH	BC
	CALL	_crc32
	POP	BC
	POP	BC
;  206			ptr += got;
.LINE 206

	LD	BC,(IX+%FFFFFFE6)
	LD	HL,(IX+%FFFFFFEC)
	ADD	HL,BC
	LD	(IX+%FFFFFFEC),HL
;  207			putch('.');
.LINE 207

	LD	BC,46
	PUSH	BC
	CALL	_putch
	POP	BC
;  208		}
L_48:
.LINE 208

	LD	BC,16384
	PUSH	BC
	LD	BC,(IX+%FFFFFFEC)
	PUSH	BC
	LD	C,(IX+%FFFFFFEF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFE6),HL
	LD	BC,HL
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	C,L_49
;  209		crcresult = crc32_finalize();
.LINE 209

	CALL	_crc32_finalize
	LD	(IX+%FFFFFFDE),HL
	LD	(IX+%FFFFFFE1),E
;  210		printf("\r\n");
.LINE 210

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__43
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  211		// Final memory check to given crc32
;  212		if(crcresult != moscrc) {
.LINE 212

	LD	HL,(_moscrc)
	LD	A,(_moscrc+3)
	LD	E,A
	LD	BC,(IX+%FFFFFFDE)
	LD	A,(IX+%FFFFFFE1)
	CALL	__lcmpu
	JR	Z,L_52
;  213			printf("Error reading file to memory\r\n");
.LINE 213

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__45
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  214			return false;
.LINE 214

	XOR	A,A
	JR	L_81
;  215		}
L_52:
.LINE 215

;  216		printf("\r\n");	
.LINE 216

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__46
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  217		// Actual work here	
;  218		di();								// prohibit any access to the old MOS firmware
.LINE 218

	di
;  219	
;  220		attempt = 0;
.LINE 220

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
;  221		while((!success) && (attempt < 3)) {
.LINE 221

	JR	L_78
L_79:
;  222			// start address in flash
;  223			addressto = FLASHSTART;
.LINE 223

	LD	BC,0
	LD	(IX+%FFFFFFF3),BC
;  224			addressfrom = BUFFER1;
.LINE 224

	LD	BC,327680
	LD	(IX+%FFFFFFF0),BC
;  225			// Write attempt#
;  226			if(attempt > 0) printf("Retry attempt #%d\r\n", attempt);
.LINE 226

	LD	BC,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JP	P,L_55
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__48
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,(IX+%FFFFFFFA)
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,L__49
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
L_55:
;  227			// Unprotect and erase flash
;  228			printf("Erasing flash... ");
.LINE 228

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__50
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  229			enableFlashKeyRegister();	// unlock Flash Key Register, so we can write to the Flash Write/Erase protection registers
.LINE 229

	CALL	_enableFlashKeyRegister
;  230			FLASH_PROT = 0;				// disable protection on all 8x16KB blocks in the flash
.LINE 230

	XOR	A,A
	OUT0	(250),A
;  231			enableFlashKeyRegister();	// will need to unlock again after previous write to the flash protection register
.LINE 231

	CALL	_enableFlashKeyRegister
;  232			FLASH_FDIV = 0x5F;			// Ceiling(18Mhz * 5,1us) = 95, or 0x5F
.LINE 232

	LD	A,%5F
	OUT0	(249),A
;  233			
;  234			for(counter = 0; counter < FLASHPAGES; counter++)
.LINE 234

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_61
L_59:
;  235			{
;  236				FLASH_PAGE = counter;
.LINE 236

	LD	A,(IX+%FFFFFFFD)
	OUT0	(252),A
;  237				FLASH_PGCTL = 0x02;			// Page erase bit enable, start erase
.LINE 237

	LD	A,%2
	OUT0	(255),A
;  238	
;  239				do
L_57:
.LINE 239

;  240				{
;  241					value = FLASH_PGCTL;
.LINE 241

	IN0	A,(255)
	LD	(IX+%FFFFFFE5),A
;  242				}
;  243				while(value & 0x02);// wait for completion of erase			
.LINE 243

	AND	A,%2
	JR	NZ,L_57
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  244			}
L_61:
.LINE 244

	LD	BC,128
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_59
;  245			printf("\r\n");
.LINE 245

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__53
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  246					
;  247			// determine number of pages to write
;  248			pagemax = filesize/PAGESIZE;
.LINE 248

	LD	HL,(IX+%FFFFFFE9)
	LD	A,%A
	CALL	__ishru_b
	LD	(IX+%FFFFFFF7),HL
;  249			if(filesize%PAGESIZE) // last page has less than PAGESIZE bytes
.LINE 249

	LD	BC,1023
	LD	HL,(IX+%FFFFFFE9)
	CALL	__iand
	LD	(IX+%FFFFFFDB),HL
	CALL	__icmpzero
	JR	Z,L_64
;  250			{
;  251				pagemax += 1;
.LINE 251

	LD	BC,(IX+%FFFFFFF7)
	INC	BC
	LD	(IX+%FFFFFFF7),BC
;  252				lastpagebytes = filesize%PAGESIZE;			
.LINE 252

	LD	BC,(IX+%FFFFFFDB)
	LD	(IX+%FFFFFFE2),BC
;  253			}
;  254			else lastpagebytes = PAGESIZE; // normal last page
.LINE 254

	JR	L_72
L_64:
	LD	BC,1024
	LD	(IX+%FFFFFFE2),BC
L_72:
;  255			
;  256			// write out each page to flash
;  257			for(counter = 0; counter < pagemax; counter++)
.LINE 257

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_71
L_69:
;  258			{
;  259				printf("\rWriting flash page %03d/%03d", counter+1, pagemax);
.LINE 259

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__55
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%3
	LD	(___print_fmt+5),A
	LD	A,%40
	LD	(___print_fmt+1),A
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,47
	PUSH	BC
	CALL	___print_uputch
	POP	BC
	LD	A,%3
	LD	(___print_fmt+5),A
	LD	A,%40
	LD	(___print_fmt+1),A
	LD	BC,(IX+%FFFFFFF7)
	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
;  260				
;  261				if(counter == (pagemax - 1)) // last page to write - might need to write less than PAGESIZE
.LINE 261

	LD	IY,(IX+%FFFFFFF7)
	LEA	HL,IY+%FFFFFFFF
	LD	BC,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_67
;  262					fastmemcpy(addressto,addressfrom,lastpagebytes);				
.LINE 262

	LD	BC,(IX+%FFFFFFE2)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF0)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF3)
	PUSH	BC
	CALL	_fastmemcpy
	POP	BC
	POP	BC
	POP	BC
;  263					//printf("Fake copy to %lx, from %lx, %lx bytes\r\n",addressto, addressfrom, lastpagebytes);
;  264				else 
.LINE 264

	JR	L_68
L_67:
;  265					fastmemcpy(addressto,addressfrom,PAGESIZE);
.LINE 265

	LD	BC,1024
	PUSH	BC
	LD	BC,(IX+%FFFFFFF0)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF3)
	PUSH	BC
	CALL	_fastmemcpy
	POP	BC
	POP	BC
	POP	BC
L_68:
;  266					//printf("Fake copy to %lx, from %lx, %lx bytes\r\n",addressto, addressfrom, PAGESIZE);
;  267			
;  268				addressto += PAGESIZE;
.LINE 268

	LD	BC,1024
	LD	HL,(IX+%FFFFFFF3)
	ADD	HL,BC
	LD	(IX+%FFFFFFF3),HL
;  269				addressfrom += PAGESIZE;
.LINE 269

	LD	HL,(IX+%FFFFFFF0)
	ADD	HL,BC
	LD	(IX+%FFFFFFF0),HL
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  270			}
L_71:
.LINE 270

	LD	BC,(IX+%FFFFFFF7)
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JR	C,L_69
;  271			lockFlashKeyRegister();	// lock the flash before WARM reset
.LINE 271

	CALL	_lockFlashKeyRegister
;  272			printf("\r\nChecking CRC... ");
.LINE 272

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__58
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  273			crc32_initialize();
.LINE 273

	CALL	_crc32_initialize
;  274			crc32(FLASHSTART, filesize);
.LINE 274

	LD	BC,(IX+%FFFFFFE9)
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_crc32
	POP	BC
	POP	BC
;  275			crcresult = crc32_finalize();
.LINE 275

	CALL	_crc32_finalize
	LD	BC,HL
	LD	(IX+%FFFFFFDE),BC
	LD	(IX+%FFFFFFE1),E
;  276			if(crcresult == moscrc) {
.LINE 276

	LD	HL,(_moscrc)
	LD	A,(_moscrc+3)
	LD	E,A
	LD	A,(IX+%FFFFFFE1)
	CALL	__lcmpu
	JR	NZ,L_75
;  277				printf("OK\r\n");
.LINE 277

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__60
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  278				success = true;
.LINE 278

	LD	(IX+%FFFFFFF6),%1
;  279			}
;  280			else {
.LINE 280

	JR	L_77
L_75:
;  281				printf("ERROR\r\n");
.LINE 281

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__61
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  282			}
L_77:
.LINE 282

;  283			attempt++;
.LINE 283

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
;  284		}
L_78:
.LINE 284

	LD	A,(IX+%FFFFFFF6)
	OR	A,A
	JR	NZ,L_80
	LD	BC,3
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JP	M,L_79
L_80:
;  285		printf("\r\n");
.LINE 285

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__64
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  286		return success;
.LINE 286

	LD	A,(IX+%FFFFFFF6)
;  287	}
L_81:
.LINE 287

	LD	SP,IX
	POP	IX
	RET	


;**************************** _update_mos ***************************
;Name                         Addr/Register   Size   Type
;_lockFlashKeyRegister               IMPORT  -----   function
;_fastmemcpy                         IMPORT  -----   function
;___print_fmt                        IMPORT     19   variable
;_enableFlashKeyRegister             IMPORT  -----   function
;__u_itoa                            IMPORT  -----   function
;_moscrc                             STATIC      4   variable
;_crc32_finalize                     IMPORT  -----   function
;_mos_fread                          IMPORT  -----   function
;_crc32                              IMPORT  -----   function
;_crc32_initialize                   IMPORT  -----   function
;_getFileSize                        IMPORT  -----   function
;_mos_fopen                          IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_putch                              IMPORT  -----   function
;G_0                                  IX-37      3   variable
;crcresult                            IX-34      4   variable
;lastpagebytes                        IX-30      3   variable
;value                                IX-27      1   variable
;got                                  IX-26      3   variable
;filesize                             IX-23      3   variable
;ptr                                  IX-20      3   variable
;file                                 IX-17      1   variable
;addressfrom                          IX-16      3   variable
;addressto                            IX-13      3   variable
;success                              IX-10      1   variable
;pagemax                               IX-9      3   variable
;attempt                               IX-6      3   variable
;counter                               IX-3      3   variable
;filename                              IX+6      3   parameter


; Stack Frame Size: 46 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "update_mos",287,"_update_mos"
	SEGMENT STRSECT
L__40:
	DB	"Programming MOS firmware to ez80 flash..."
	DB	13,10,13,10,0
L__41:
	DB	"Reading MOS firmware"
	DB	0
L__43:
	DB	13,10,0
L__45:
	DB	"Error reading file to memory"
	DB	13,10,0
L__46:
	DB	13,10,0
L__48:
	DB	"Retry attempt #"
	DB	0
L__49:
	DB	13,10,0
L__50:
	DB	"Erasing flash... "
	DB	0
L__53:
	DB	13,10,0
L__55:
	DB	13
	DB	"Writing flash page "
	DB	0
L__58:
	DB	13,10
	DB	"Checking CRC... "
	DB	0
L__60:
	DB	"OK"
	DB	13,10,0
L__61:
	DB	"ERROR"
	DB	13,10,0
L__64:
	DB	13,10,0
	SEGMENT CODE
;  288	
;  289	void echoVDP(uint8_t value) {
_echoVDP:
.DEFINE "_echoVDP"

.VALUE _echoVDP

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "echoVDP",289,"_echoVDP"

.LINE 289

.DEFINE "value"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  290		putch(23);
.LINE 290

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;  291		putch(0);
.LINE 291

	LD	BC,0
	PUSH	BC
	CALL	_putch
	POP	BC
;  292		putch(0x80);
.LINE 292

	LD	BC,128
	PUSH	BC
	CALL	_putch
	POP	BC
;  293		putch(value);
.LINE 293

	LD	A,(IX+%6)
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;  294		delayms(100);
.LINE 294

	LD	BC,100
	PUSH	BC
	CALL	_delayms
	POP	BC
;  295	}
.LINE 295

	LD	SP,IX
	POP	IX
	RET	


;**************************** _echoVDP ***************************
;Name                         Addr/Register   Size   Type
;_delayms                            IMPORT  -----   function
;_putch                              IMPORT  -----   function
;value                                 IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "echoVDP",295,"_echoVDP"
;  296	
;  297	int getCommand(const char *command) {
_getCommand:
.DEFINE "_getCommand"

.VALUE _getCommand

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "getCommand",297,"_getCommand"

.LINE 297

.DEFINE "command"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  298		if(memcmp(command, "all\0", 4) == 0) return CMDALL;
.LINE 298

	LD	BC,4
	PUSH	BC
	LD	BC,L__67
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_85
	LD	HL,1
	JR	L_97
L_85:
;  299		if(memcmp(command, "mos\0", 4) == 0) return CMDMOS;
.LINE 299

	LD	BC,4
	PUSH	BC
	LD	BC,L__69
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_87
	LD	HL,2
	JR	L_97
L_87:
;  300		if(memcmp(command, "vdp\0", 4) == 0) return CMDVDP;
.LINE 300

	LD	BC,4
	PUSH	BC
	LD	BC,L__71
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_89
	LD	HL,3
	JR	L_97
L_89:
;  301		if(memcmp(command, "batch\0", 6) == 0) return CMDBATCH;
.LINE 301

	LD	BC,6
	PUSH	BC
	LD	BC,L__73
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_91
	LD	HL,5
	JR	L_97
L_91:
;  302		if(memcmp(command, "-f\0", 3) == 0) return CMDFORCE;
.LINE 302

	LD	BC,3
	PUSH	BC
	LD	BC,L__75
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_93
	LD	HL,4
	JR	L_97
L_93:
;  303		if(memcmp(command, "force\0", 6) == 0) return CMDFORCE;
.LINE 303

	LD	BC,6
	PUSH	BC
	LD	BC,L__77
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_95
	LD	HL,4
	JR	L_97
L_95:
;  304		if(memcmp(command, "-force\0", 7) == 0) return CMDFORCE;
.LINE 304

	LD	BC,7
	PUSH	BC
	LD	BC,L__79
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_96
	LD	HL,4
	JR	L_97
L_96:
;  305		return CMDUNKNOWN;
.LINE 305

	OR	A,A
	SBC	HL,HL
;  306	}
L_97:
.LINE 306

	LD	SP,IX
	POP	IX
	RET	


;**************************** _getCommand ***************************
;Name                         Addr/Register   Size   Type
;_memcmp                             IMPORT  -----   function
;command                               IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "getCommand",306,"_getCommand"
	SEGMENT STRSECT
L__67:
	DB	"all"
	DB	0,0
L__69:
	DB	"mos"
	DB	0,0
L__71:
	DB	"vdp"
	DB	0,0
L__73:
	DB	"batch"
	DB	0,0
L__75:
	DB	"-f"
	DB	0,0
L__77:
	DB	"force"
	DB	0,0
L__79:
	DB	"-force"
	DB	0,0
	SEGMENT CODE
;  307	
;  308	bool parseCommands(int argc, char *argv[]) {
_parseCommands:
.DEFINE "_parseCommands"

.VALUE _parseCommands

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "parseCommands",308,"_parseCommands"

.LINE 308

.DEFINE "argc"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "argv"

.CLASS 65

.VALUE 9

.TYPE 290

.ENDEF

.DEFINE "argcounter"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "command"

.CLASS 65

.VALUE -15

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF1
	LD	SP,HL
;  309		int argcounter;
;  310		int command;
;  311	
;  312		argcounter = 1;
.LINE 312

	LD	BC,1
	LD	(IX+%FFFFFFFD),BC
;  313		while(argcounter < argc) {
.LINE 313

	JR	L_128
L_129:
;  314			command = getCommand(argv[argcounter]);
.LINE 314

	LD	HL,(IX+%FFFFFFFD)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+%9)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_getCommand
	POP	BC
	LD	(IX+%FFFFFFF1),HL
;  315			switch(command) {
.LINE 315

	CALL	__seqcaseD
	JP	(HL)
L__82:
	DW	6
	DW	0
	DB	0
	DW24	L_98	

	DW24	L_99	

	DW24	L_103	

	DW24	L_111	

	DW24	L_122	

	DW24	L_119	

	DW24	L_127	

;  316				case CMDUNKNOWN:
L_98:
.LINE 316

;  317					return false;
.LINE 317

	XOR	A,A
	JR	L_136
;  318					break;
;  319				case CMDALL:
L_99:
.LINE 319

;  320					if(flashmos || flashvdp) return false;
.LINE 320

	LD	A,(_flashmos)
	OR	A,A
	JR	NZ,L_101
	LD	A,(_flashvdp)
	OR	A,A
	JR	Z,L_102
L_101:
	XOR	A,A
	JR	L_136
L_102:
;  321					strcpy(mosfilename, DEFAULT_MOSFIRMWARE);
.LINE 321

	LD	BC,L__85
	PUSH	BC
	LD	BC,_mosfilename
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  322					strcpy(vdpfilename, DEFAULT_VDPFIRMWARE);
.LINE 322

	LD	BC,L__86
	PUSH	BC
	LD	BC,_vdpfilename
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  323					flashmos = true;
.LINE 323

	LD	A,%1
	LD	(_flashmos),A
;  324					flashvdp = true;
.LINE 324

	LD	(_flashvdp),A
;  325					break;
.LINE 325

	JR	L_127
;  326				case CMDMOS:
L_103:
.LINE 326

;  327					if(flashmos) return false;
.LINE 327

	LD	A,(_flashmos)
	OR	A,A
	JR	Z,L_109
	XOR	A,A
	JR	L_136
L_109:
;  328					if((argc > (argcounter+1)) && (getCommand(argv[argcounter + 1]) == CMDUNKNOWN)) {
.LINE 328

	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
	LD	BC,(IX+%6)
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	JP	P,L_108
	LD	HL,(IX+%FFFFFFFA)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+%9)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_getCommand
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_108
;  329						strcpy(mosfilename, argv[argcounter + 1]);
.LINE 329

	LD	HL,(IX+%FFFFFFFA)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+%9)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,_mosfilename
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  330						argcounter++;
.LINE 330

	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFFD),BC
;  331					}
;  332					else {
.LINE 332

	JR	L_110
L_108:
;  333						strcpy(mosfilename, DEFAULT_MOSFIRMWARE);
.LINE 333

	LD	BC,L__90
	PUSH	BC
	LD	BC,_mosfilename
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  334					}
L_110:
.LINE 334

;  335					flashmos = true;
.LINE 335

	LD	A,%1
	LD	(_flashmos),A
;  336					break;
.LINE 336

	JR	L_127
;  337				case CMDVDP:
L_111:
.LINE 337

;  338					if(flashvdp) return false;
.LINE 338

	LD	A,(_flashvdp)
	OR	A,A
	JR	Z,L_117
	XOR	A,A
	JR	L_136
L_117:
;  339					if((argc > (argcounter+1)) && (getCommand(argv[argcounter + 1]) == CMDUNKNOWN)) {
.LINE 339

	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFF7),BC
	LD	BC,(IX+%6)
	LD	HL,(IX+%FFFFFFF7)
	OR	A,A
	SBC	HL,BC
	JP	P,L_116
	LD	HL,(IX+%FFFFFFF7)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+%9)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_getCommand
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_116
;  340						strcpy(vdpfilename, argv[argcounter + 1]);
.LINE 340

	LD	HL,(IX+%FFFFFFF7)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,(IX+%9)
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,_vdpfilename
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  341						argcounter++;
.LINE 341

	LD	BC,(IX+%FFFFFFF7)
	LD	(IX+%FFFFFFFD),BC
;  342					}
;  343					else {
.LINE 343

	JR	L_118
L_116:
;  344						strcpy(vdpfilename, DEFAULT_VDPFIRMWARE);
.LINE 344

	LD	BC,L__94
	PUSH	BC
	LD	BC,_vdpfilename
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  345					}
L_118:
.LINE 345

;  346					flashvdp = true;
.LINE 346

	LD	A,%1
	LD	(_flashvdp),A
;  347					break;
.LINE 347

	JR	L_127
;  348				case CMDBATCH:
L_119:
.LINE 348

;  349					if(optbatch) return false;
.LINE 349

	LD	A,(_optbatch)
	OR	A,A
	JR	Z,L_121
	XOR	A,A
	JR	L_136
L_121:
;  350					optbatch = true;
.LINE 350

	LD	A,%1
	LD	(_optbatch),A
;  351					optforce = true;
.LINE 351

	LD	(_optforce),A
;  352					break;
.LINE 352

	JR	L_127
;  353				case CMDFORCE:
L_122:
.LINE 353

;  354					if(optforce && !optbatch) return false;
.LINE 354

	LD	A,(_optforce)
	OR	A,A
	JR	Z,L_125
	LD	A,(_optbatch)
	OR	A,A
	JR	NZ,L_125
	XOR	A,A
	JR	L_136
L_125:
;  355					optforce = true;
.LINE 355

	LD	A,%1
	LD	(_optforce),A
;  356					break;
;  357			}
L_127:
.LINE 357

;  358			argcounter++;
.LINE 358

	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  359		}
L_128:
.LINE 359

	LD	BC,(IX+%6)
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JP	M,L_129
;  360		return (flashvdp || flashmos);
.LINE 360

	LD	A,(_flashvdp)
	OR	A,A
	JR	NZ,L_131
	LD	A,(_flashmos)
	OR	A,A
	JR	Z,L_132
L_131:
;  361	}
.LINE 361

	LD	BC,1
	LD	(IX+%FFFFFFF4),BC
	JR	L_133
L_132:
	LD	BC,0
	LD	(IX+%FFFFFFF4),BC
L_133:
	LD	A,(IX+%FFFFFFF4)
L_136:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _parseCommands ***************************
;Name                         Addr/Register   Size   Type
;_optforce                           STATIC      1   variable
;_optbatch                           STATIC      1   variable
;_vdpfilename                        STATIC    256   variable
;_mosfilename                        STATIC    256   variable
;_strcpy                             IMPORT  -----   function
;_flashvdp                           STATIC      1   variable
;_flashmos                           STATIC      1   variable
;command                              IX-15      3   variable
;temp134                              IX-12      3   variable
;G_4                                   IX-9      3   variable
;G_1                                   IX-6      3   variable
;argcounter                            IX-3      3   variable
;argv                                  IX+9      3   parameter
;argc                                  IX+6      3   parameter


; Stack Frame Size: 27 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "parseCommands",361,"_parseCommands"
	SEGMENT STRSECT
L__85:
	DB	"MOS.bin"
	DB	0
L__86:
	DB	"firmware.bin"
	DB	0
L__90:
	DB	"MOS.bin"
	DB	0
L__94:
	DB	"firmware.bin"
	DB	0
	SEGMENT CODE
;  362	
;  363	bool filesExist(void) {
_filesExist:
.DEFINE "_filesExist"

.VALUE _filesExist

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "filesExist",363,"_filesExist"

.LINE 363

.DEFINE "file"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "filesexist"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;  364		uint8_t file;
;  365		bool filesexist = true;
.LINE 365

	LD	(IX+%FFFFFFFE),%1
;  366	
;  367		if(flashmos) {
.LINE 367

	LD	A,(_flashmos)
	OR	A,A
	JR	Z,L_143
;  368			file = mos_fopen(mosfilename, fa_read);
.LINE 368

	LD	BC,1
	PUSH	BC
	LD	BC,_mosfilename
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFF),A
;  369			if(!file) {
.LINE 369

	OR	A,A
	JR	NZ,L_138
;  370				printf("Error opening MOS firmware \"%s\"\n\r",mosfilename);
.LINE 370

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__104
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,_mosfilename
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__105
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  371				filesexist = false;
.LINE 371

	LD	(IX+%FFFFFFFE),%0
;  372			}
L_138:
.LINE 372

;  373			mos_fclose(file);
.LINE 373

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  374		}
L_143:
.LINE 374

;  375	
;  376		if(flashvdp) {
.LINE 376

	LD	A,(_flashvdp)
	OR	A,A
	JR	Z,L_144
;  377			file = mos_fopen(vdpfilename, fa_read);
.LINE 377

	LD	BC,1
	PUSH	BC
	LD	BC,_vdpfilename
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFF),A
;  378			if(!file) {
.LINE 378

	OR	A,A
	JR	NZ,L_141
;  379				printf("Error opening VDP firmware \"%s\"\n\r",vdpfilename);
.LINE 379

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__108
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,_vdpfilename
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__109
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  380				filesexist = false;
.LINE 380

	LD	(IX+%FFFFFFFE),%0
;  381			}
L_141:
.LINE 381

;  382			mos_fclose(file);
.LINE 382

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  383		}
L_144:
.LINE 383

;  384	
;  385		return filesexist;
.LINE 385

	LD	A,(IX+%FFFFFFFE)
;  386	}
.LINE 386

	LD	SP,IX
	POP	IX
	RET	


;**************************** _filesExist ***************************
;Name                         Addr/Register   Size   Type
;_vdpfilename                        STATIC    256   variable
;_flashvdp                           STATIC      1   variable
;_mos_fclose                         IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_mosfilename                        STATIC    256   variable
;_mos_fopen                          IMPORT  -----   function
;_flashmos                           STATIC      1   variable
;filesexist                            IX-2      1   variable
;file                                  IX-1      1   variable


; Stack Frame Size: 8 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "filesExist",386,"_filesExist"
	SEGMENT STRSECT
L__104:
	DB	"Error opening MOS firmware \""
	DB	0
L__105:
	DB	"\""
	DB	10,13,0
L__108:
	DB	"Error opening VDP firmware \""
	DB	0
L__109:
	DB	"\""
	DB	10,13,0
	SEGMENT CODE
;  387	
;  388	bool validFirmwareFiles(void) {
_validFirmwareFiles:
.DEFINE "_validFirmwareFiles"

.VALUE _validFirmwareFiles

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "validFirmwareFiles",388,"_validFirmwareFiles"

.LINE 388

.DEFINE "file"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "validfirmware"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

.DEFINE "filesize"

.CLASS 65

.VALUE -5

.TYPE 14

.ENDEF

.DEFINE "buffer"

.CLASS 65

.VALUE -41

.DIM 36

.TYPE 108

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFD7
	LD	SP,HL
;  389		uint8_t file;
;  390		uint24_t filesize;
;  391		uint8_t buffer[ESP32_MAGICLENGTH + ESP32_MAGICSTART];
;  392		bool validfirmware = true;
.LINE 392

	LD	(IX+%FFFFFFFE),%1
;  393	
;  394		if(flashmos) {
.LINE 394

	LD	A,(_flashmos)
	OR	A,A
	JR	Z,L_154
;  395			file = mos_fopen(mosfilename, fa_read);
.LINE 395

	LD	BC,1
	PUSH	BC
	LD	BC,_mosfilename
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFF),A
;  396			mos_fread(file, (char *)BUFFER1, MOS_MAGICLENGTH);
.LINE 396

	LD	BC,5
	PUSH	BC
	LD	BC,327680
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  397			if(!containsMosHeader((uint8_t *)BUFFER1)) {
.LINE 397

	LD	BC,327680
	PUSH	BC
	CALL	_containsMosHeader
	POP	BC
	OR	A,A
	JR	NZ,L_147
;  398				printf("\"%s\" does not contain valid MOS ez80 startup code\r\n", mosfilename);
.LINE 398

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,34
	PUSH	BC
	CALL	___print_uputch
	POP	BC
	LD	BC,_mosfilename
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__113
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  399				validfirmware = false;
.LINE 399

	LD	(IX+%FFFFFFFE),%0
;  400			}
L_147:
.LINE 400

;  401			filesize = getFileSize(file);
.LINE 401

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_getFileSize
	POP	BC
	LD	(IX+%FFFFFFFB),HL
;  402			if(filesize > FLASHSIZE) {
.LINE 402

	LD	BC,HL
	LD	HL,131072
	OR	A,A
	SBC	HL,BC
	JR	NC,L_149
;  403				printf("\"%s\" too large for 128KB embedded flash\r\n", mosfilename);
.LINE 403

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,34
	PUSH	BC
	CALL	___print_uputch
	POP	BC
	LD	BC,_mosfilename
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__115
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  404				validfirmware = false;
.LINE 404

	LD	(IX+%FFFFFFFE),%0
;  405			}
L_149:
.LINE 405

;  406			mos_fclose(file);
.LINE 406

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  407		}
L_154:
.LINE 407

;  408		if(flashvdp) {
.LINE 408

	LD	A,(_flashvdp)
	OR	A,A
	JR	Z,L_155
;  409			file = mos_fopen(vdpfilename, fa_read);
.LINE 409

	LD	BC,1
	PUSH	BC
	LD	BC,_vdpfilename
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFF),A
;  410			mos_fread(file, (char *)buffer, ESP32_MAGICLENGTH + ESP32_MAGICSTART);
.LINE 410

	LD	BC,36
	PUSH	BC
	PEA	IX+%FFFFFFD7
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  411			if(!containsESP32Header(buffer)) {
.LINE 411

	PEA	IX+%FFFFFFD7
	CALL	_containsESP32Header
	POP	BC
	OR	A,A
	JR	NZ,L_152
;  412				printf("\"%s\" does not contain valid ESP32 code\r\n", vdpfilename);
.LINE 412

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,34
	PUSH	BC
	CALL	___print_uputch
	POP	BC
	LD	BC,_vdpfilename
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__118
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  413				validfirmware = false;
.LINE 413

	LD	(IX+%FFFFFFFE),%0
;  414			}
L_152:
.LINE 414

;  415			mos_fclose(file);
.LINE 415

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  416		}
L_155:
.LINE 416

;  417		return validfirmware;
.LINE 417

	LD	A,(IX+%FFFFFFFE)
;  418	}
.LINE 418

	LD	SP,IX
	POP	IX
	RET	


;**************************** _validFirmwareFiles ***************************
;Name                         Addr/Register   Size   Type
;_vdpfilename                        STATIC    256   variable
;_flashvdp                           STATIC      1   variable
;_mos_fclose                         IMPORT  -----   function
;_getFileSize                        IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_mos_fread                          IMPORT  -----   function
;_mosfilename                        STATIC    256   variable
;_mos_fopen                          IMPORT  -----   function
;_flashmos                           STATIC      1   variable
;buffer                               IX-41     36   variable
;filesize                              IX-5      3   variable
;validfirmware                         IX-2      1   variable
;file                                  IX-1      1   variable


; Stack Frame Size: 47 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "validFirmwareFiles",418,"_validFirmwareFiles"
	SEGMENT STRSECT
L__113:
	DB	"\" does not contain valid MOS ez80 startup code"
	DB	13,10,0
L__115:
	DB	"\" too large for 128KB embedded flash"
	DB	13,10,0
L__118:
	DB	"\" does not contain valid ESP32 code"
	DB	13,10,0
	SEGMENT CODE
;  419	
;  420	void showCRC32(void) {
_showCRC32:
.DEFINE "_showCRC32"

.VALUE _showCRC32

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "showCRC32",420,"_showCRC32"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  421		if(flashmos) printf("MOS CRC 0x%04lX\r\n", moscrc);
.LINE 421

	LD	A,(_flashmos)
	OR	A,A
	JR	Z,L_159
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__121
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%4
	LD	(___print_fmt+5),A
	LD	A,%60
	LD	(___print_fmt+1),A
	LD	A,%78
	LD	(___print_fmt+4),A
	LD	A,(_moscrc+3)
	LD	C,A
	LD	B,%0
	PUSH	BC
	LD	BC,(_moscrc)
	PUSH	BC
	CALL	__u_ultoa
	POP	BC
	POP	BC
	LD	BC,L__122
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
L_159:
;  422		if(flashvdp) printf("VDP CRC 0x%04lX\r\n", vdpcrc);
.LINE 422

	LD	A,(_flashvdp)
	OR	A,A
	JR	Z,L_160
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__124
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	A,%4
	LD	(___print_fmt+5),A
	LD	A,%60
	LD	(___print_fmt+1),A
	LD	A,%78
	LD	(___print_fmt+4),A
	LD	A,(_vdpcrc+3)
	LD	C,A
	LD	B,%0
	PUSH	BC
	LD	BC,(_vdpcrc)
	PUSH	BC
	CALL	__u_ultoa
	POP	BC
	POP	BC
	LD	BC,L__125
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
L_160:
;  423		printf("\r\n");
.LINE 423

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__126
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  424	}
.LINE 424

	LD	SP,IX
	POP	IX
	RET	


;**************************** _showCRC32 ***************************
;Name                         Addr/Register   Size   Type
;_vdpcrc                             STATIC      4   variable
;_flashvdp                           STATIC      1   variable
;_moscrc                             STATIC      4   variable
;__u_ultoa                           IMPORT  -----   function
;___print_fmt                        IMPORT     19   variable
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_flashmos                           STATIC      1   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "showCRC32",424,"_showCRC32"
	SEGMENT STRSECT
L__121:
	DB	"MOS CRC 0x"
	DB	0
L__122:
	DB	13,10,0
L__124:
	DB	"VDP CRC 0x"
	DB	0
L__125:
	DB	13,10,0
L__126:
	DB	13,10,0
	SEGMENT CODE
;  425	
;  426	void calculateCRC32(void) {
_calculateCRC32:
.DEFINE "_calculateCRC32"

.VALUE _calculateCRC32

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "calculateCRC32",426,"_calculateCRC32"

.LINE 426

.DEFINE "file"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "ptr"

.CLASS 65

.VALUE -4

.TYPE 34

.ENDEF

.DEFINE "got"

.CLASS 65

.VALUE -7

.TYPE 14

.ENDEF

.DEFINE "size"

.CLASS 65

.VALUE -10

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
	DEC	SP
;  427		uint8_t file;
;  428		uint24_t got,size;
;  429		char* ptr;
;  430	
;  431		moscrc = 0;
.LINE 431

	LD	BC,0
	XOR	A,A
	LD	(_moscrc),BC
	LD	(_moscrc+3),A
;  432		vdpcrc = 0;
.LINE 432

	XOR	A,A
	LD	(_vdpcrc),BC
	LD	(_vdpcrc+3),A
;  433	
;  434		printf("Calculating CRC");
.LINE 434

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__128
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  435	
;  436		if(flashmos) {
.LINE 436

	LD	A,(_flashmos)
	OR	A,A
	JR	Z,L_172
;  437			ptr = (char*)BUFFER1;
.LINE 437

	LD	BC,327680
	LD	(IX+%FFFFFFFC),BC
;  438			file = mos_fopen(mosfilename, fa_read);
.LINE 438

	LD	BC,1
	PUSH	BC
	LD	BC,_mosfilename
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFF),A
;  439			crc32_initialize();
.LINE 439

	CALL	_crc32_initialize
;  440			
;  441			// Read file to memory
;  442			while((got = mos_fread(file, ptr, BLOCKSIZE)) > 0) {
.LINE 442

	JR	L_162
L_163:
;  443				crc32(ptr, got);
.LINE 443

	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	CALL	_crc32
	POP	BC
	POP	BC
;  444				ptr += got;
.LINE 444

	LD	BC,(IX+%FFFFFFF9)
	LD	HL,(IX+%FFFFFFFC)
	ADD	HL,BC
	LD	(IX+%FFFFFFFC),HL
;  445				putch('.');
.LINE 445

	LD	BC,46
	PUSH	BC
	CALL	_putch
	POP	BC
;  446			}		
L_162:
.LINE 446

	LD	BC,16384
	PUSH	BC
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF9),HL
	LD	BC,HL
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JR	C,L_163
;  447			moscrc = crc32_finalize();
.LINE 447

	CALL	_crc32_finalize
	LD	(_moscrc),HL
	LD	A,E
	LD	(_moscrc+3),A
;  448			mos_fclose(file);
.LINE 448

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  449		}
L_172:
.LINE 449

;  450		if(flashvdp) {
.LINE 450

	LD	A,(_flashvdp)
	OR	A,A
	JR	Z,L_173
;  451			file = mos_fopen(vdpfilename, fa_read);
.LINE 451

	LD	BC,1
	PUSH	BC
	LD	BC,_vdpfilename
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFF),A
;  452			crc32_initialize();
.LINE 452

	CALL	_crc32_initialize
;  453			while(1) {
L_169:
.LINE 453

;  454				size = mos_fread(file, (char *)BUFFER1, BLOCKSIZE);
.LINE 454

	LD	BC,16384
	PUSH	BC
	LD	BC,327680
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF6),HL
;  455				if(size == 0) break;
.LINE 455

	CALL	__icmpzero
	JR	Z,L_170
;  456				putch('.');
.LINE 456

	LD	BC,46
	PUSH	BC
	CALL	_putch
	POP	BC
;  457				crc32((char *)BUFFER1, size);
.LINE 457

	LD	BC,(IX+%FFFFFFF6)
	PUSH	BC
	LD	BC,327680
	PUSH	BC
	CALL	_crc32
	POP	BC
	POP	BC
	JR	L_169
;  458			}
L_170:
.LINE 458

;  459			vdpcrc = crc32_finalize();
.LINE 459

	CALL	_crc32_finalize
	LD	(_vdpcrc),HL
	LD	A,E
	LD	(_vdpcrc+3),A
;  460			mos_fclose(file);
.LINE 460

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  461		}
L_173:
.LINE 461

;  462		printf("\r\n\r\n");
.LINE 462

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__133
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  463	}
.LINE 463

	LD	SP,IX
	POP	IX
	RET	


;**************************** _calculateCRC32 ***************************
;Name                         Addr/Register   Size   Type
;_vdpfilename                        STATIC    256   variable
;_flashvdp                           STATIC      1   variable
;_mos_fclose                         IMPORT  -----   function
;_crc32_finalize                     IMPORT  -----   function
;_mos_fread                          IMPORT  -----   function
;_putch                              IMPORT  -----   function
;_crc32                              IMPORT  -----   function
;_crc32_initialize                   IMPORT  -----   function
;_mosfilename                        STATIC    256   variable
;_mos_fopen                          IMPORT  -----   function
;_flashmos                           STATIC      1   variable
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_vdpcrc                             STATIC      4   variable
;_moscrc                             STATIC      4   variable
;size                                 IX-10      3   variable
;got                                   IX-7      3   variable
;ptr                                   IX-4      3   variable
;file                                  IX-1      1   variable


; Stack Frame Size: 16 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "calculateCRC32",463,"_calculateCRC32"
	SEGMENT STRSECT
L__128:
	DB	"Calculating CRC"
	DB	0
L__133:
	DB	13,10,13,10,0
	SEGMENT CODE
;  464	
;  465	int main(int argc, char * argv[]) {	
_main:
.DEFINE "_main"

.VALUE _main

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "main",465,"_main"

.LINE 465

.DEFINE "argc"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "argv"

.CLASS 65

.VALUE 9

.TYPE 290

.ENDEF

.DEFINE "n"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "sysvars"

.CLASS 65

.VALUE -6

.TAG "NONAME3"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	DEC	SP
	DEC	SP
;  466		sysvar_t *sysvars;
;  467		int n;
;  468		uint16_t tmp;
;  469		sysvars = getsysvars();
.LINE 469

	CALL	_getsysvars
	LD	(IX+%FFFFFFFA),HL
;  470	
;  471		// All checks
;  472		if(argc == 1) {
.LINE 472

	LD	BC,1
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_177
;  473			usage();
.LINE 473

	CALL	_usage
;  474			return 0;
.LINE 474

	OR	A,A
	SBC	HL,HL
	JR	L_216
;  475		}
L_177:
.LINE 475

;  476		if(!parseCommands(argc, argv)) {
.LINE 476

	LD	BC,(IX+%9)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_parseCommands
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_179
;  477			usage();
.LINE 477

	CALL	_usage
;  478			return EXIT_INVALIDPARAMETER;
.LINE 478

	LD	HL,19
	JR	L_216
;  479		}
L_179:
.LINE 479

;  480		if(!filesExist()) return EXIT_FILENOTFOUND;
.LINE 480

	CALL	_filesExist
	OR	A,A
	JR	NZ,L_181
	LD	HL,4
	JR	L_216
L_181:
;  481		if(!validFirmwareFiles()) {
.LINE 481

	CALL	_validFirmwareFiles
	OR	A,A
	JR	NZ,L_182
;  482			return EXIT_INVALIDPARAMETER;
.LINE 482

	LD	HL,19
	JR	L_216
;  483		}
L_182:
.LINE 483

;  484	
;  485		putch(12);
.LINE 485

	LD	BC,12
	PUSH	BC
	CALL	_putch
	POP	BC
;  486		print_version();
.LINE 486

	CALL	_print_version
;  487		calculateCRC32();
.LINE 487

	CALL	_calculateCRC32
;  488		// Skip showing CRC32 and user input when 'silent' is requested
;  489		if(!optforce) {
.LINE 489

	LD	A,(_optforce)
	OR	A,A
	JR	NZ,L_186
;  490			putch(12);
.LINE 490

	LD	BC,12
	PUSH	BC
	CALL	_putch
	POP	BC
;  491			print_version();
.LINE 491

	CALL	_print_version
;  492			showCRC32();
.LINE 492

	CALL	_showCRC32
;  493			if(!getResponse()) return 0;
.LINE 493

	CALL	_getResponse
	OR	A,A
	JR	NZ,L_186
	OR	A,A
	SBC	HL,HL
	JR	L_216
;  494		}
L_186:
.LINE 494

;  495		if(optbatch) beep(1);
.LINE 495

	LD	A,(_optbatch)
	OR	A,A
	JR	Z,L_199
	LD	BC,1
	PUSH	BC
	CALL	_beep
	POP	BC
L_199:
;  496	
;  497		if(flashvdp) {
.LINE 497

	LD	A,(_flashvdp)
	OR	A,A
	JR	Z,L_214
;  498			while(sysvars->scrheight == 0); // wait for 1st feedback from VDP
L_188:
.LINE 498

	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%11)
	LD	(IX+%FFFFFFF8),C
	LD	(IX+%FFFFFFF9),B
	LD	HL,(IX+%FFFFFFF8)
	CALL	__scmpzero
	JR	Z,L_188
;  499			tmp = sysvars->scrheight;
;  500			sysvars->scrheight = 0;
.LINE 500

	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%11),%0
	LD	(IY+%12),%0
;  501			if(update_vdp(vdpfilename)) {
.LINE 501

	LD	BC,_vdpfilename
	PUSH	BC
	CALL	_update_vdp
	POP	BC
	OR	A,A
	JR	Z,L_197
;  502				echoVDP(1);
.LINE 502

	LD	BC,1
	PUSH	BC
	CALL	_echoVDP
	POP	BC
;  503				while(sysvars->scrheight == 0);
L_191:
.LINE 503

	LD	IY,(IX+%FFFFFFFA)
	LD	HL,(IY+%11)
	CALL	__scmpzero
	JR	Z,L_191
;  504				if(optbatch) beep(2);
.LINE 504

	LD	A,(_optbatch)
	OR	A,A
	JR	Z,L_214
	LD	BC,2
	PUSH	BC
	CALL	_beep
	POP	BC
;  505			}
;  506			else {
.LINE 506

	JR	L_214
L_197:
;  507				if(!optforce && flashmos) {
.LINE 507

	LD	A,(_optforce)
	OR	A,A
	JR	NZ,L_214
	LD	A,(_flashmos)
	OR	A,A
	JR	Z,L_214
;  508					askEscapeToContinue();
.LINE 508

	CALL	_askEscapeToContinue
;  509					sysvars->scrheight = tmp;
.LINE 509

	LD	BC,(IX+%FFFFFFF8)
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%11),C
	LD	(IY+%12),B
;  510				}
;  511			}
;  512		}
L_214:
.LINE 512

;  513	
;  514		if(flashmos) {
.LINE 514

	LD	A,(_flashmos)
	OR	A,A
	JR	Z,L_215
;  515			if(update_mos(mosfilename)) {
.LINE 515

	LD	BC,_mosfilename
	PUSH	BC
	CALL	_update_mos
	POP	BC
	OR	A,A
	JR	Z,L_212
;  516				printf("\r\nDone\r\n\r\n");
.LINE 516

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__151
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  517				if(optbatch) {
.LINE 517

	LD	A,(_optbatch)
	OR	A,A
	JR	Z,L_208
;  518					printf("Press reset button");
.LINE 518

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__153
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  519					beep(3);
.LINE 519

	LD	BC,3
	PUSH	BC
	CALL	_beep
	POP	BC
;  520					while(1); // don't repeatedly run this command batched (autoexec.txt)
L_201:
.LINE 520

	JR	L_201
;  521				}
;  522				else {
L_208:
.LINE 522

;  523					printf("System reset in ");
.LINE 523

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__154
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  524					for(n = 3; n > 0; n--) {
.LINE 524

	LD	BC,3
	LD	(IX+%FFFFFFFD),BC
	JR	L_205
L_203:
;  525						printf("%d...", n);
.LINE 525

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,(IX+%FFFFFFFD)
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,L__155
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  526						delayms(1000);
.LINE 526

	LD	BC,1000
	PUSH	BC
	CALL	_delayms
	POP	BC
	LD	BC,(IX+%FFFFFFFD)
	DEC	BC
	LD	(IX+%FFFFFFFD),BC
;  527					}
L_205:
.LINE 527

	LD	BC,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	JP	M,L_203
;  528					reset();
.LINE 528

	CALL	_reset
;  529				}
;  530			}
;  531			else {
.LINE 531

	JR	L_215
L_212:
;  532				printf("\r\nMultiple errors occured during flash write.\r\n");
.LINE 532

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__157
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  533				printf("Bare-metal recovery required.\r\n");
.LINE 533

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__158
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  534				while(1); // No live MOS to return to
L_210:
.LINE 534

	JR	L_210
;  535			}
;  536		}
L_215:
.LINE 536

;  537		return 0;
.LINE 537

	OR	A,A
	SBC	HL,HL
;  538	}
L_216:
.LINE 538

	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_reset                              IMPORT  -----   function
;_delayms                            IMPORT  -----   function
;__u_itoa                            IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_mosfilename                        STATIC    256   variable
;_flashmos                           STATIC      1   variable
;_vdpfilename                        STATIC    256   variable
;_flashvdp                           STATIC      1   variable
;_optbatch                           STATIC      1   variable
;_optforce                           STATIC      1   variable
;_putch                              IMPORT  -----   function
;_getsysvars                         IMPORT  -----   function
;G_7                                   IX-8      2   variable
;sysvars                               IX-6      3   variable
;n                                     IX-3      3   variable
;argv                                  IX+9      3   parameter
;argc                                  IX+6      3   parameter


; Stack Frame Size: 20 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "main",538,"_main"
	SEGMENT STRSECT
L__151:
	DB	13,10
	DB	"Done"
	DB	13,10,13,10,0
L__153:
	DB	"Press reset button"
	DB	0
L__154:
	DB	"System reset in "
	DB	0
L__155:
	DB	"..."
	DB	0
L__157:
	DB	13,10
	DB	"Multiple errors occured during flash write."
	DB	13,10,0
L__158:
	DB	"Bare-metal recovery required."
	DB	13,10,0
	XREF _memcmp:ROM
	XREF _strcpy:ROM
	XREF _getFileSize:ROM
	XREF _crc32_finalize:ROM
	XREF _crc32_initialize:ROM
	XREF _crc32:ROM
	XREF _delayms:ROM
	XREF _startVDPupdate:ROM
	XREF _reset:ROM
	XREF _fastmemcpy:ROM
	XREF _lockFlashKeyRegister:ROM
	XREF _enableFlashKeyRegister:ROM
	XREF _mos_fread:ROM
	XREF _mos_fclose:ROM
	XREF _mos_fopen:ROM
	XREF _getsysvars:ROM
	XREF _getch:ROM
	XREF _tolower:ROM
	XREF __u_ultoa:ROM
	XREF __u_itoa:ROM
	XREF ___print_sendstring:ROM
	XREF ___print_xputch:ROM
	XREF ___print_uputch:ROM
	XREF ___print_fmt:ROM
	XREF __lcmpu:ROM
	XREF __iand:ROM
	XREF __stoiu:ROM
	XREF __itol:ROM
	XREF __scmpzero:ROM
	XREF __icmpzero:ROM
	XREF __seqcaseD:ROM
	XREF __ishru_b:ROM
	XREF __ishrs_b:ROM
	XDEF _main
	XDEF _calculateCRC32
	XDEF _showCRC32
	XDEF _validFirmwareFiles
	XDEF _filesExist
	XDEF _parseCommands
	XDEF _getCommand
	XDEF _echoVDP
	XDEF _update_mos
	XDEF _update_vdp
	XDEF _askEscapeToContinue
	XDEF _getResponse
	XDEF _usage
	XDEF _print_version
	XDEF _containsESP32Header
	XDEF _esp32_magicnumbers
	XDEF _containsMosHeader
	XDEF _mos_magicnumbers
	XDEF _vdp_ota_present
	XDEF _getCharAt
	XDEF _beep
	XDEF _putch
	XDEF _optforce
	XDEF _optbatch
	XDEF _vdpcrc
	XDEF _vdpfilename
	XDEF _flashvdp
	XDEF _moscrc
	XDEF _mosfilename
	XDEF _flashmos
	XDEF _errno
	END
